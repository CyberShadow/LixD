Lix hacker's guide
==================

How to use and hack the Lix source.



Building Lix
------------

Look in the `build' directory and read the file for your operating system.

That file has instructions on how to install a D compiler, the build system
dub, and the required libraries.



Finishing the port
------------------

Simon shall search the code for instances of DTODO, which mark things that
shall be tested/altered when most things have been ported.

Instances of DTODOLANG point to missing use of the Language class, which
has not yet been ported.



LF or CRLF terminators
----------------------

Source code should have LF terminators. Anything else is crazy.

I don't care about what's used in level or replay files. Lix can read them
with either, and tools like grep or sed will work, too. Inspecting them with
an interactive editor is a nice-to-have, but not required.

Documentation (all ./doc/* files) and translations (all ./data/transl/* files)
should have CRLF endings. They must be accessible by Windows Notepad users.

The translations (./data/transl/*) should get a UTF-8 byte-order mark, and then
immediately a CRLF linebreak, for maximum compatibility. I haven't done so yet.



Source code formatting
----------------------

Indentation is 4 spaces. Indenting with tabs is a bug. Indenting with less
than 4 spaces is unreadable. While 8 spaces would be more readable, it's a
little much for D code.

Don't nest stuff deeper than 4 or 5 levels, treating classes and functions
as a nesting level. Write more functions instead. D allows you to declare
private functions at module level, or to declare local functions.

Most non-function things get the opening brace '{' on the same line:
if, while, for[each], class, struct, etc.

    if (condition) {
        a = 5;
        do_something();
    }

Nothing goes on the same line as '}', not even else or while. You shouldn't
use do-while much anyway. Whenever a simple while doesn't do, use for or
foreach.

Omit braces when a statement is followed by single line. Don't omit braces
when at least one of the if-else branches has more than one statement.

    scope (exit)
        clean_up();

    if (condition)
        do_something();

    if (another_condition) {
        do_something_else();
    }
    else {
        a + 4;
        do_whatever();
    }

Functions have the opening brace on a separate line. You can put the function
name on its own line, apart from the return values.

    int
    my_function(int a)
    {
        return something(a * 3);
    }

    private nothrow void
    almost_like_java() const @nogc
    {
        // ...
    }

When you can fit an entire function definition into a single line, do that
instead of following the above rule. This happens often with class properties.

    @property int some_value()      { return _some_value;     }
    @property int some_value(int i) { return _some_value = i; }

The D style (http://dlang.org/dstyle.html) recommends properties over
get/set_some_value(). The private variable should be prefixed with an
underscore, because it needs a name different from the property functions.

Digression: The D style also recommends to choose type names LikeThis,
which I do myself, and other identifier names likeThis, different from my
like_this. Maybe I should move the codebase to the dStyleNamingConvention.
The current convention is influenced by my C++ history.

When a line, conditional expression or parameter list gets very long and
has to be broken into separate lines, format it like this:

    private int
    my_function(
        LongClassName    long_argument_1,
        AnotherClassName long_argument_2
    ) {
        do_something();
    }

    if (   my_long_expression     == some_value
        && another_long_expression > some_other_value
    ) {
        do_something();
        do_something_else();
    }

Reason: Anything else requires a third, made-up level of identation to
differentiate between the expression/parameter list and the body. ") {" is
shorter than the indentation width of 4 spaces, and therefore is a good
visual separator.

This rule takes precedence over "put the opening brace on the same line".
There is no "the" line anyway.

Align things horizontally. For this, do what you believe is easiest to read.



Notes about D
-------------

*   To search the web, use "dlang" in your query. e.g., "dlang writefln".
    Alternatively, use "d programming language".

*   const int* foo() { ... } is the same as int* foo() const { ... }, both
    are valid D and do what the latter would have done in C++: make the method
    callable on a const class object. If you want to return a const pointer:
    const(int*) foo() { ... }; a pointer to const int: const(int)* foo().
    Mnemonic: When describing a const/immutable type, always use brackets.

*   To do formatted output to stdout, use writefln() in std.stdio, which works
    like printf(). The equivalent to C's sprintf() is format() in std.string,
    which returns a D string.

*   D is garbage-collected by default. You can still do RAII by allocating
    resources in the constructor this(), and deallocate in ~this(). To invoke
    the deallocation at the correct time, call destroy(myobject), which calls
    the destructor and prevents automatic calls to the destructor later.
    This was clear(myobject) in older versions of D, but that's deprecated.
