Lix hacker's guide
==================

How to use and hack the Lix source.



Building Lix
------------

Look in the `build' directory and read the file for your operating system.

That file has instructions on how to install a D compiler, the build system
dub, and the required libraries.



Finishing the port
------------------

Simon shall search the code for instances of DTODO, which mark things that
shall be tested/altered when most things have been ported.

Instances of DTODOLANG point to missing use of the Language class, which
has not yet been ported.



LF or CRLF terminators
----------------------

Source code should have LF terminators. Anything else is crazy.

I don't care about what's used in level or replay files. Lix can read them
with either, and tools like grep or sed will work, too. Inspecting them with
an interactive editor is a nice-to-have, but not required.

Documentation (all ./doc/* files) and translations (all ./data/transl/* files)
should have CRLF endings. They must be accessible by Windows Notepad users.

The translations (./data/transl/*) should get a UTF-8 byte-order mark, and then
immediately a CRLF linebreak, for maximum compatibility. I haven't done so yet.



Source code formatting
----------------------

Indentation is 4 spaces. Indenting with tabs is a bug. Indenting with less
than 4 spaces is unreadable. While 8 spaces would be more readable, it's a
little much for D code.

Don't nest stuff deeper than 4 or 5 levels, treating classes and functions
as a nesting level. Write more functions instead. D allows you to declare
private functions at module level, or to declare local functions.

Most non-function things get the opening brace '{' on the same line:
if, while, for[each], class, struct, etc.

    if (condition) {
        a = 5;
        doSomething();
    }

Nothing goes on the same line as '}', not even else or while. You shouldn't
use do-while much anyway. Whenever a simple while doesn't do, use for or
foreach.

Omit braces when a statement is followed by single line. Don't omit braces
when at least one of the if-else branches has more than one statement.

    scope (exit)
        cleanUp();

    if (condition)
        doSomething();

    if (anotherCondition) {
        doSomethingElse();
    }
    else {
        number += 4;
        doWhatever();
    }

Functions have the opening brace on a separate line. You can put the function
name on its own line, apart from the return values.

    int
    myFunction(int a)
    {
        return something(a * 3);
    }

    private nothrow void
    almostLikeJava() const @nogc
    {
        // ...
    }

When you can fit an entire function definition into a single line, do that
instead of following the above rule. This happens often with class properties.

    @property int someValue()      { return _someValue;     }
    @property int someValue(int i) { return _someValue = i; }

The D style (http://dlang.org/dstyle.html) recommends properties over
get/set_some_value(). The private variable should be prefixed with an
underscore, because it needs a name different from the property functions.

Digression: The D style also recommends to choose type names LikeThis,
which I do myself, and other identifier names likeThis. I'm in the middle
of a conversion of the D codebase to this convention. My old convention was
to name non-type symbols like_this, as you would do in C. Guideline:
Use one underscore at the beginning of a private field, and no underscores
anywhere else, even if some of my old symbols still violate this guideline.

When a line, conditional expression or parameter list gets very long and
has to be broken into separate lines, format it like this:

    private int
    myFunction(
        LongClassName    longArgument1,
        AnotherClassName longArgument2
    ) {
        doSomething();
    }

    if (   myLongExpression     == someValue
        && anotherLongExpression > someOtherValue
    ) {
        doSomething();
        doSomethingElse();
    }

Reason: Anything else requires a third, made-up level of identation to
differentiate between the expression/parameter list and the body. ") {" is
shorter than the indentation width of 4 spaces, and therefore is a good
visual separator.

This rule takes precedence over "put the opening brace on the same line".
There is no "the" line anyway.

Align things horizontally. For this, do what you believe is easiest to read.



Sending in patches
------------------

You are encouraged to use git to send in patches. Either send your commits
to me by email -- see the default readme for my contact data -- or make a
github pull request.

Please limit the first line of your git commit messages to 50 characters.
If you want to write a longer message, make a blank line below the first,
and then add more lines of at most 72 characters each.



Notes about D
-------------

*   To search the web, use "dlang" in your query, e.g., "dlang writefln".
    Alternatively, use "d programming language". Google wants to be smart,
    and brings results like "he'd" or "that'd" when you search for "dlang",
    because it has learned that a single "d" is wanted. The computer wants to
    be smarter than the user again. :-/

*   const int* foo() { ... } is the same as int* foo() const { ... }, both
    are valid D and do what the latter would have done in C++: make the method
    callable on a const class object. If you want to return a const pointer:
    const(int*) foo() { ... }; a pointer to const int: const(int)* foo().
    Mnemonic: When describing a const/immutable type, always use brackets.

*   To do formatted output to stdout, use writefln() in std.stdio, which works
    like printf(). The equivalent to C's sprintf() is format() in std.string,
    which returns a D string.

*   You can do RAII by allocating resources in the constructor this(), and
    deallocate in ~this(). To invoke the deallocation at the correct time,
    use a struct, not a class -- classes are garbage-collected, structs are
    destroyed deterministically at end of scope. Remember that a dynamic
    array of structs is garbage-collected.

*   If you really want to have deterministic destruction for classes,
    call destroy(myclassobject), which calls the destructor. Some large and
    important types are imagined best as classes, not structs, and still need
    deterministic cleanup -- rely on your good taste. destroy(myobject) was
    clear(myobject) in older versions of D. Destroying a class object doesn't
    prevent the GC from running the destructor once again later, when the
    object's fields are all set to their .init values! If you deallocate
    resources in your destructor, wrap them in a check whether the
    resource pointer is not null.
